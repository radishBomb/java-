1.Redis 和 Memcached 有啥区别？
  Redis 支持复杂的数据结构
  Redis 原生支持集群模式
  Redis 在存储小数据时比 Memcached 性能更高。而在 100k 以上的数据中，Memcached 性能要高于 Redis

2.Redis 的线程模型
  Redis 内部使用文件事件处理器 file event handler ，这个文件事件处理器是单线程的，所以 Redis 才叫做单线程的模型。
  它采用 IO 多路复用机制同时监听多个 socket，将产生事件的 socket 压入内存队列中，事件分派器根据 socket 上的事件类型来选择对应的事件处理器进行处理。

  文件事件处理器的结构包含 4 个部分：
      多个 socket
      IO 多路复用程序
      文件事件分派器
      事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）

3.为啥 Redis 单线程模型也能效率这么高？
  纯内存操作。
  核心是基于非阻塞的 IO 多路复用机制。
  C 语言实现，一般来说，C 语言实现的程序“距离”操作系统更近，执行速度相对会更快。
  单线程反而避免了多线程的频繁上下文切换问题，预防了多线程可能产生的竞争问题。

4.Redis 6.0 开始引入多线程
  注意！ Redis 6.0 之后的版本抛弃了单线程模型这一设计，原本使用单线程运行的 Redis 也开始选择性地使用多线程模型。
  前面还在强调 Redis 单线程模型的高效性，现在为什么又要引入多线程？这其实说明 Redis 在有些方面，单线程已经不具有优势了。因为读写网络的 Read/Write 系统调用在 Redis 执行期间占用了大部分 CPU 时间，如果把网络读写做成多线程的方式对性能会有很大提升。
  Redis 的多线程部分只是用来处理网络数据的读写和协议解析，执行命令仍然是单线程。 之所以这么设计是不想 Redis 因为多线程而变得复杂，需要去控制 key、lua、事务、LPUSH/LPOP 等等的并发问题。

5.Redis 主要有以下几种数据类型：
  Strings:  就是普通的 set 和 get，做简单的 KV 缓存。
  Hashes : 这个是类似 map 的一种结构，这个一般就是可以将结构化的数据，比如一个对象（前提是这个对象没嵌套其他的对象）给缓存在 Redis 里，然后每次读写缓存的时候，可以就操作 hash 里的某个字段。
  Lists : 可以做简单的消息队列
  Sets ： 无序集合，自动去重。
  Sorted Sets ： 排序的 set，去重但可以排序

6.Redis 过期策略
  定期删除：  Redis 默认是每隔 100ms 就随机抽取一些设置了过期时间的 key，检查其是否过期，如果过期就删除。
  惰性删除： 获取 key 的时候，如果此时 key 已经过期，就删除，不会返回任何东西。

  注 ： slave 不会过期 key，只会等待 master 过期 key。如果 master 过期了一个 key，或者通过 LRU 淘汰了一个 key，那么会模拟一条 del 命令发送给 slave。

7.如果大量过期 key 堆积在内存里，导致 Redis 内存块耗尽了，咋整？
  走内存淘汰机制。
  Redis 内存淘汰机制有以下几个：
    noeviction: 当内存不足以容纳新写入数据时，新写入操作会报错，这个一般没人用吧，实在是太恶心了。
    allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）。
    allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个 key，这个一般没人用吧，为啥要随机，肯定是把最近最少使用的 key 给干掉啊。
    volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的 key（这个一般不太合适）。
    volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个 key。
    volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的 key 优先移除。

8.如何保证 redis 的高并发和高可用
  redis 主从架构 （一般是三主三从）
  redis 基于哨兵实现高可用

9.Redis 主从架构
  单机的 Redis，能够承载的 QPS 大概就在上万到几万不等。对于缓存来说，一般都是用来支撑读高并发的。
  因此架构做成主从(master-slave)架构，一主多从，主负责写，并且将数据复制到其它的 slave 节点，从节点负责读。所有的读请求全部走从节点。
  这样也可以很轻松实现水平扩容，支撑读高并发。

10.Redis replication 的核心机制
   Redis 采用异步方式复制数据到 slave 节点，不过 Redis2.8 开始，slave node 会周期性地确认自己每次复制的数据量；
   一个 master node 是可以配置多个 slave node 的；
   slave node 也可以连接其他的 slave node；
   slave node 做复制的时候，不会 block master node 的正常工作；
   slave node 在做复制的时候，也不会 block 对自己的查询操作，它会用旧的数据集来提供服务；但是复制完成的时候，需要删除旧数据集，加载新数据集，这个时候就会暂停对外服务了；
   slave node 主要用来进行横向扩容，做读写分离，扩容的 slave node 可以提高读的吞吐量。


11.Redis 主从复制的断点续传
   master node 会在内存中维护一个 backlog，master 和 slave 都会保存一个 副本 offset 还有一个 master run id，offset 就是保存在 backlog 中的。
   如果 master 和 slave 网络连接断掉了，slave 会让 master 从上次 副本 offset 开始继续复制，
   如果没有找到对应的 offset，那么就会执行一次 重新同步 。

12.Redis 持久化的两种方式
   RDB（快照）：RDB 持久化机制，是对 Redis 中的数据执行周期性的持久化。
   AOF：AOF 机制对每条写入命令作为日志，以 append-only 的模式写入一个日志文件中，在 Redis 重启的时候，可以通过回放 AOF 日志中的写入指令来重新构建整个数据集。

   注：Redis 支持同时开启开启两种持久化方式，我们可以综合使用 AOF 和 RDB 两种持久化机制，用 AOF 来保证数据不丢失，作为数据恢复的第一选择；
   用 RDB 来做不同程度的冷备，在 AOF 文件都丢失或损坏不可用的时候，还可以使用 RDB 来进行快速的数据恢复。

13. Redis 集群元数据的维护有两种方式
    集中式、Gossip 协议。Redis cluster 节点间采用 gossip 协议进行通信。

    集中式：是将集群元数据（节点信息、故障等等）集中存储在某个节点上。 例如 基于 zookeeper（分布式协调的中间件）对所有元数据进行存储维护。
    gossip 协议：所有节点都持有一份元数据，不同的节点如果出现了元数据的变更，就不断将元数据发送给其它的节点，让其它节点也进行元数据的变更。

14. 什么是 缓存雪崩
    缓存机器意外发生了全盘宕机，请求全部落数据库，数据库必然扛不住，它会报一下警，然后就挂了,这就是缓存雪崩。

15. redis 缓存雪崩解决方案
    事前：Redis 高可用，主从+哨兵，Redis cluster，避免全盘崩溃。
    事中：本地 ehcache 缓存 + hystrix 限流&降级，避免 MySQL 被打死。
    事后：Redis 持久化，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据。

16. 什么是缓存穿透
    发送过来的请求缓存都无法命中,视缓存于无物,直接查询数据库。这种恶意攻击场景的缓存穿透就会直接把数据库给打死。

17. redis 缓存穿透解决方案
    数据库中只要没查到，就写一个空值到缓存里去,然后设置一个过期时间，这样的话，下次有相同的 key 来访问的时候，在缓存失效之前，都可以直接从缓存中取数据。
    使用布隆过滤器对访问的请求起到一定的初筛作用，避免了因数据不存在引起的查询压力。

18. 什么是缓存击穿
    缓存击穿，就是说某个 key 非常热点，访问非常频繁，处于集中式高并发访问的情况，
    当这个 key 在失效的瞬间，大量的请求就击穿了缓存，直接请求数据库，就像是在一道屏障上凿开了一个洞。

19. redis 缓存击穿解决方案
   不同场景下的解决方式可如下：

   若缓存的数据是基本不会发生更新的，则可尝试将该热点数据设置为永不过期。
   若缓存的数据更新不频繁，且缓存刷新的整个流程耗时较少的情况下，则可以采用基于 Redis、zookeeper 等分布式中间件的分布式互斥锁，或者本地互斥锁以保证仅少量的请求能请求数据库并重新构建缓存，其余线程则在锁释放后能访问到新缓存。
   若缓存的数据更新频繁或者在缓存刷新的流程耗时较长的情况下，可以利用定时线程在缓存过期前主动地重新构建缓存或者延后缓存的过期时间，以保证所有的请求能一直访问到对应的缓存。

20. 如何保证缓存与数据库的双写一致性？
    读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。
    更新的时候，先删除缓存 然后再更新数据库   (并发量大的情况下会有可能出现问题)

    极端情况（缓存+数据库 必须保持一致性）： 读请求和写请求串行化，串到一个内存队列里去。串行化可以保证一定不会出现不一致的情况，但是它也会导致系统的吞吐量大幅度降低，用比正常情况下多几倍的机器去支撑线上的一个请求。



